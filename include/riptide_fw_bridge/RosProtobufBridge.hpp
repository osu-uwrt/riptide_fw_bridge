#pragma once

#include <functional>
#include <memory>
#include <string>
#include <vector>
#include <rclcpp/rclcpp.hpp>
#include "protobridge.pb.h"

namespace RosProtobufBridge {

// ========================================
// Message Conversion
// ========================================

class MsgConversionError : public std::runtime_error {
public:
    MsgConversionError(const std::string& msg, const std::string& field, const std::string& error) :
        runtime_error("Failed to convert ROS message '" + msg + "' field '" + field + "': " + error) {}
};

typedef std::function<void(int clientId, const std::string& data)> ProtobufTxCB;

class MessageHandlerItf;

class RosProtobufBridge {
    friend class MessageHandlerItf;
public:
    RosProtobufBridge(std::string target, ProtobufTxCB txCallback);
    void processPacket(int clientId, const void *data, size_t size);
    void spin();
protected:
    void sendResponse(int clientId, const titan_pb::comm_msg &msg);
private:
    uint32_t protocol_version_;
    rclcpp::Node::SharedPtr node_;
    std::mutex tx_mutex_;
    ProtobufTxCB txCallback_;
    std::shared_ptr<MessageHandlerItf> topicHandler;
    std::shared_ptr<MessageHandlerItf> paramHandler;
};


// ========================================
// Autogenerated Message Handlers (from Python)
// ========================================

class MessageHandlerItf {
public:
    virtual bool processMessage(int clientId, const titan_pb::comm_msg &msg) = 0;
protected:
    MessageHandlerItf(RosProtobufBridge &bridge): bridge_(bridge) {}
    void sendResponse(int clientId, const titan_pb::comm_msg &msg) {
        bridge_.sendResponse(clientId, msg);
    }

    RosProtobufBridge &bridge_;
};

std::shared_ptr<MessageHandlerItf> createTopicHandler(rclcpp::Node& node, RosProtobufBridge &bridge, std::string target);
std::shared_ptr<MessageHandlerItf> createParamHandler(rclcpp::Node& node, RosProtobufBridge &bridge);

}
